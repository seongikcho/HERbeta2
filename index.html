<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>HER - íšŒìƒ‰ì§€ëŒ€</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="theme-color" content="#000000" />
  <link rel="manifest" href="manifest.webmanifest" />
  <style>
    * { box-sizing: border-box; padding: 0; margin: 0; }
    html, body {
      width: 100%;
      height: 100%;
      background: #000;
      color: #f5f5f5;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }
    body {
      display: flex;
      flex-direction: column;
    }
    #gameLayout {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }

    /* ìƒë‹¨ ê²Œì„ ì˜ì—­ */
    #gameArea {
      position: relative;
      flex: 1 1 auto;
      min-height: 260px;
      background: #000;
      overflow: hidden;
    }
    canvas#game {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
      touch-action: none;
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      pointer-events: none;
      text-shadow: 0 0 6px rgba(0,0,0,0.9);
      z-index: 11;
    }
    #hud-top {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 2px;
      font-size: 16px;
      margin-bottom: 4px;
    }
    #hud-hp {
      font-size: 18px;
      font-weight: 700;
      color: #ff5555;
    }
    #hud-timer {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(0,0,0,0.9);
      z-index: 12;
    }
    #hud-stage {
      font-size: 14px;
      opacity: 0.9;
    }
    #hud-energy {
      font-size: 12px;
      opacity: 0.85;
    }

    /* í™”ë©´ í…Œë‘ë¦¬ (ì´ˆë¡ë‹¬ ë•Œ) */
    #screenFrame {
      position: absolute;
      inset: 0;
      pointer-events: none;
      border: 3px solid transparent;
      box-shadow: none;
      z-index: 9;
    }
    #screenFrame.green {
      border-color: rgba(0,255,153,0.75);
      box-shadow: 0 0 22px rgba(0,255,153,0.8);
      animation: greenPulse 0.5s infinite alternate;
    }
    @keyframes greenPulse {
      0% { opacity: 0.25; }
      100% { opacity: 1; }
    }

    /* íŠœí† ë¦¬ì–¼ íŒíŠ¸ (ì²« ë‹¬ ì´ˆë¡) */
    #tutorialHint {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      padding: 22px 30px;
      background: rgba(0,0,0,0.9);
      border-radius: 14px;
      border: 2px solid #00ff99;
      font-size: 16px;
      line-height: 1.8;
      text-align: center;
      max-width: 420px;
      z-index: 15;
      box-shadow: 0 0 18px rgba(0,255,153,0.5);
    }
    #tutorialHint.hidden {
      display: none;
    }

    /* ì˜¤ë²„ë ˆì´ ê³µí†µ (ì‹œì‘/ì—…ê·¸ë ˆì´ë“œ/íŒ¨ë°°/í´ë¦¬ì–´) */
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.88);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 24px;
      z-index: 20;
    }
    .overlay.hidden {
      display: none;
    }
    .overlay-title {
      font-size: 24px;
      margin-bottom: 10px;
      font-weight: 700;
    }
    .overlay-sub {
      font-size: 14px;
      margin-bottom: 18px;
      line-height: 1.6;
      white-space: pre-line;
    }
    .overlay-btn {
      padding: 12px 26px;
      border-radius: 999px;
      border: 1px solid #00ff99;
      background: #0f3f2a;
      color: #f5f5f5;
      font-size: 15px;
      font-weight: 600;
      box-shadow: 0 0 12px rgba(0,255,153,0.7);
      touch-action: manipulation;
    }

    /* ì—…ê·¸ë ˆì´ë“œ í™”ë©´ ë°°ì¹˜ */
    #upgradeOverlay {
      align-items: stretch;
      justify-content: flex-start;
      padding-top: 48px;
    }
    #upgradeOverlay .overlay-title {
      text-align: center;
    }
    #upgradeStats {
      font-size: 14px;
      margin-bottom: 16px;
      text-align: center;
      white-space: pre-line;
    }
    .upgrade-button {
      width: 100%;
      padding: 12px 10px;
      border-radius: 10px;
      border: 1px solid #444;
      background: #202020;
      color: #f5f5f5;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 8px;
      text-align: left;
      line-height: 1.4;
      touch-action: manipulation;
    }
    .upgrade-title-line {
      display: flex;
      justify-content: space-between;
      margin-bottom: 3px;
    }
    .upgrade-desc {
      font-size: 12px;
      opacity: 0.8;
    }
    #upgradeContinue {
      margin-top: 16px;
      align-self: center;
    }

    /* íŒ¨ë°° ìŠ¤ì½”ì–´ */
    #deadScoreWrap {
      margin-top: 8px;
      margin-bottom: 28px;
      text-align: center;
    }
    #deadScoreBreakdown {
      font-size: 13px;
      line-height: 1.7;
      opacity: 0.9;
      white-space: pre-line;
    }
    #deadScoreFinal {
      margin-top: 12px;
      font-size: 22px;
      font-weight: 800;
      color: #00ffcc;
      text-shadow: 0 0 12px rgba(0,255,204,0.9);
      letter-spacing: 0.04em;
    }

    /* í•˜ë‹¨ ì»¨íŠ¸ë¡¤ ì˜ì—­ (ì¡°ì´ìŠ¤í‹± + ê·€í™˜ ë²„íŠ¼ + íŒíŠ¸) */
    #controlArea {
      flex: 0 0 150px;
      display: flex;
      flex-direction: column;
      background: rgba(0,0,0,0.96);
      border-top: 1px solid rgba(255,255,255,0.06);
      padding: 6px 10px 8px;
    }
    #controlTop {
      flex: 1 1 auto;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
    }

    /* ì¡°ì´ìŠ¤í‹± (ë ˆì´ì•„ì›ƒ ë¶„ë¦¬, ì¤‘ì•™ ê¸°ì¤€) */
    #joystick {
      position: relative;
      width: 140px;
      height: 140px;
      touch-action: none;
    }
    #stick-base {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 90px;
      height: 90px;
      margin-left: -45px;
      margin-top: -45px;
      border-radius: 50%;
      background: rgba(0,0,0,0.6);
      border: 2px solid rgba(255,255,255,0.2);
    }
    #stick-knob {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 44px;
      height: 44px;
      margin-left: -22px;
      margin-top: -22px;
      border-radius: 50%;
      background: rgba(255,255,255,0.75);
    }

    /* ê·€í™˜ ë²„íŠ¼ */
    #returnButton {
      align-self: center;
      width: 140px;
      height: 54px;
      border-radius: 12px;
      background: #222;
      border: 2px solid #555;
      color: #f5f5f5;
      font-size: 13px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-shadow: 0 0 10px rgba(0,0,0,0.7);
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    #returnButton.active {
      background: #0f3f2a;
      border-color: #00ff99;
      box-shadow: 0 0 18px rgba(0,255,153,0.7);
    }
    #returnButton.disabled {
      opacity: 0.4;
    }

    /* í•˜ë‹¨ ì‘ì€ ì•ˆë‚´ (ìŠ¤í…Œì´ì§€ë³„) */
    #smallHint {
      width: 100%;
      text-align: center;
      font-size: 11px;
      margin-top: 4px;
      opacity: 0;
      transition: opacity 0.8s ease-out;
      pointer-events: none;
      text-shadow: 0 0 4px rgba(0,0,0,0.8);
      white-space: pre-line;
      min-height: 14px;
    }
    #smallHint.visible {
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <div id="gameLayout">
    <!-- ìƒë‹¨ ê²Œì„ ì˜ì—­ -->
    <div id="gameArea">
      <canvas id="game"></canvas>

      <div id="screenFrame"></div>

      <!-- HUD -->
      <div id="hud">
        <div id="hud-top">
          <div id="hud-hp">HP 100</div>
          <div id="hud-stage">Stage 1 (íšŒìƒ‰ì§€ëŒ€)</div>
        </div>
        <div id="hud-timer">00:00</div>
        <div id="hud-energy">ì—ë„ˆì§€: 0 | ì´: 0</div>
      </div>

      <!-- íŠœí† ë¦¬ì–¼ íŒíŠ¸ (ì²« ë‹¬ ì´ˆë¡) -->
      <div id="tutorialHint" class="hidden">
        ë‹¬ì´ ì´ˆë¡ìƒ‰ìœ¼ë¡œ ë³€í–ˆì„ ë•Œ<br>
        <span style="color:#00ff99;font-weight:700;">ì˜¤ë¥¸ìª½ ì•„ë˜ ë²„íŠ¼</span>ì„ ëˆŒëŸ¬ì•¼<br>
        í˜„ì‹¤ë¡œ ê·€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
      </div>

      <!-- ì‹œì‘ í™”ë©´ -->
      <div id="startOverlay" class="overlay">
        <div class="overlay-title">HER</div>
        <div class="overlay-sub">
          íšŒìƒ‰ì§€ëŒ€ì—ì„œ 29.5ì´ˆë¥¼ ë²„í‹°ê³ ,<br>
          ë‹¬ì´ ì´ˆë¡ìƒ‰ì¼ ë•Œ í˜„ì‹¤ë¡œ ê·€í™˜í•˜ì„¸ìš”.<br><br>
          ì™„ì „íˆ íŒ¨ë°°í•˜ë©´ ëª¨ë“  ì—…ê·¸ë ˆì´ë“œì™€<br>
          ìŠ¤í…Œì´ì§€ê°€ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.
        </div>
        <button id="startButton" class="overlay-btn">í„°ì¹˜í•´ì„œ ì‹œì‘</button>
      </div>

      <!-- ì—…ê·¸ë ˆì´ë“œ í™”ë©´ -->
      <div id="upgradeOverlay" class="overlay hidden">
        <div class="overlay-title">í˜„ì‹¤ - ë¬´ê¸° ì—…ê·¸ë ˆì´ë“œ</div>
        <div id="upgradeStats"></div>

        <button class="upgrade-button" data-upgrade="attack">
          <div class="upgrade-title-line">
            <span>ê³µê²©ë ¥ ì¦ê°€</span><span>[10 ì—ë„ˆì§€]</span>
          </div>
          <div class="upgrade-desc">ì´ì•Œê³¼ ê·¼ì ‘ ê³µê²©ì˜ í”¼í•´ëŸ‰ì´ ì¦ê°€í•©ë‹ˆë‹¤.</div>
        </button>

        <button class="upgrade-button" data-upgrade="fireRate">
          <div class="upgrade-title-line">
            <span>ë°œì‚¬ ê°„ê²© ê°ì†Œ</span><span>[10 ì—ë„ˆì§€]</span>
          </div>
          <div class="upgrade-desc">íƒ„í™˜/ê·¼ì ‘ ê³µê²© ì‚¬ì´ì˜ ëŒ€ê¸° ì‹œê°„ì´ ê°ì†Œí•©ë‹ˆë‹¤.</div>
        </button>

        <button class="upgrade-button" data-upgrade="moveSpeed">
          <div class="upgrade-title-line">
            <span>ì´ë™ ì†ë„ ì¦ê°€</span><span>[10 ì—ë„ˆì§€]</span>
          </div>
          <div class="upgrade-desc">íšŒìƒ‰ì§€ëŒ€ì—ì„œì˜ ì´ë™ ì†ë„ê°€ ë¹¨ë¼ì§‘ë‹ˆë‹¤.</div>
        </button>

        <button id="upgradeContinue" class="overlay-btn">íšŒìƒ‰ì§€ëŒ€ë¡œ ëŒì•„ê°€ê¸° (ë‹¤ìŒ ìŠ¤í…Œì´ì§€)</button>
      </div>

      <!-- íŒ¨ë°° í™”ë©´ -->
      <div id="deadOverlay" class="overlay hidden">
        <div class="overlay-title">ì™„ì „ íŒ¨ë°°</div>
        <div class="overlay-sub">
          íšŒìƒ‰ì§€ëŒ€ì—ì„œ ëª©ìˆ¨ì„ ìƒì—ˆìŠµë‹ˆë‹¤.<br>
          ì§€ê¸ˆê¹Œì§€ ëª¨ì€ ì—…ê·¸ë ˆì´ë“œì™€ ìŠ¤í…Œì´ì§€ê°€<br>
          ëª¨ë‘ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.
        </div>

        <div id="deadScoreWrap">
          <div id="deadScoreBreakdown"></div>
          <div id="deadScoreFinal"></div>
        </div>

        <button id="deadRestart" class="overlay-btn">ì²˜ìŒë¶€í„° ë‹¤ì‹œ</button>
      </div>

      <!-- ìµœì¢… í´ë¦¬ì–´ -->
      <div id="clearOverlay" class="overlay hidden">
        <div class="overlay-title">HER - íšŒìƒ‰ì§€ëŒ€ íƒˆì¶œ</div>
        <div id="clearText" class="overlay-sub">
          ìë„¨ ì•„ì£¼ ë›°ì–´ë‚œ ì˜¤ì„œë…ì„œì˜ ìì§ˆì„ ê°–ì·„êµ¬ë§Œ.
        </div>
        <button id="clearRestart" class="overlay-btn">ì²˜ìŒë¶€í„° ë‹¤ì‹œ</button>
      </div>
    </div>

    <!-- í•˜ë‹¨ ì»¨íŠ¸ë¡¤ / ì•ˆë‚´ ì˜ì—­ -->
    <div id="controlArea">
      <div id="controlTop">
        <!-- ëª¨ë°”ì¼ ì¡°ì´ìŠ¤í‹± -->
        <div id="joystick">
          <div id="stick-base"></div>
          <div id="stick-knob"></div>
        </div>

        <!-- ê·€í™˜ ë²„íŠ¼ -->
        <div id="returnButton" class="disabled">í˜„ì‹¤ë¡œ ê·€í™˜</div>
      </div>

      <!-- ìŠ¤í…Œì´ì§€ë³„ í•˜ë‹¨ ì•ˆë‚´ -->
      <div id="smallHint"></div>
    </div>
  </div>

  <!-- ìŒì‚° BGM (bgm.mp3ë¥¼ ê°™ì€ í´ë”ì— ë‘ë©´ ì¬ìƒë¨) -->
  <audio id="bgm" src="bgm.mp3" loop></audio>

  <script>
    // ===== ìº”ë²„ìŠ¤ / ë ˆì´ì•„ì›ƒ =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const gameArea = document.getElementById('gameArea');

    let viewW = 0;
    let viewH = 0;

    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const rect = gameArea.getBoundingClientRect();
      viewW = rect.width;
      viewH = rect.height;
      canvas.width = viewW * dpr;
      canvas.height = viewH * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ===== UI ìš”ì†Œ =====
    const hudHp       = document.getElementById('hud-hp');
    const hudTimer    = document.getElementById('hud-timer');
    const hudStage    = document.getElementById('hud-stage');
    const hudEnergy   = document.getElementById('hud-energy');
    const screenFrame = document.getElementById('screenFrame');

    const returnButton = document.getElementById('returnButton');

    const joystick   = document.getElementById('joystick');
    const stickBase  = document.getElementById('stick-base');
    const stickKnob  = document.getElementById('stick-knob');

    const tutorialHint   = document.getElementById('tutorialHint');
    const startOverlay   = document.getElementById('startOverlay');
    const startButton    = document.getElementById('startButton');
    const upgradeOverlay = document.getElementById('upgradeOverlay');
    const upgradeStats   = document.getElementById('upgradeStats');
    const upgradeButtons = upgradeOverlay.querySelectorAll('.upgrade-button');
    const upgradeContinue = document.getElementById('upgradeContinue');
    const deadOverlay    = document.getElementById('deadOverlay');
    const deadRestart    = document.getElementById('deadRestart');
    const clearOverlay   = document.getElementById('clearOverlay');
    const clearRestart   = document.getElementById('clearRestart');
    const clearText      = document.getElementById('clearText');

    const deadScoreBreakdown = document.getElementById('deadScoreBreakdown');
    const deadScoreFinal     = document.getElementById('deadScoreFinal');

    const smallHint = document.getElementById('smallHint');

    const bgm = document.getElementById('bgm');
    let bgmStarted = false;
    function ensureBgm() {
      if (bgmStarted || !bgm) return;
      const p = bgm.play();
      if (p && typeof p.then === 'function') {
        p.catch(() => {});
      }
      bgmStarted = true;
    }

    // ===== ì¡°ì´ìŠ¤í‹± =====
    let joyActive = false;
    let joyId = null;
    let joyCenterX = 0;
    let joyCenterY = 0;
    let joyDirX = 0;
    let joyDirY = 0;
    let joyIntensity = 0;   // 0~1, ì–¼ë§ˆë‚˜ ë©€ë¦¬ ë°€ì—ˆëŠ”ì§€

    function resetJoystick() {
      joyActive = false;
      joyId = null;
      joyDirX = 0;
      joyDirY = 0;
      joyIntensity = 0;
      stickKnob.style.left = '50%';
      stickKnob.style.top  = '50%';
    }

    function joystickTouchStart(e) {
      e.preventDefault();
      ensureBgm();
      const t = e.changedTouches[0];
      if (!t) return;
      joyActive = true;
      joyId = t.identifier;
      const rect = stickBase.getBoundingClientRect();
      joyCenterX = rect.left + rect.width / 2;
      joyCenterY = rect.top + rect.height / 2;
      joystickTouchMove(e);
    }

   function joystickTouchMove(e) {
      if (!joyActive) return;
      const touches = e.touches;
      let t = null;
      for (let i = 0; i < touches.length; i++) {
        if (touches[i].identifier === joyId) {
          t = touches[i];
          break;
        }
      }
      if (!t) return;

      const rect = stickBase.getBoundingClientRect();
      const dx = t.clientX - joyCenterX;
      const dy = t.clientY - joyCenterY;
      const baseR = rect.width / 2;

      // ğŸ”¹ ì¡°ì´ìŠ¤í‹±ì´ ì›€ì§ì¼ ìˆ˜ ìˆëŠ” ì‹¤ì œ ë°˜ê²½ì„ ë” ë„“ê²Œ ì‚¬ìš©
      const maxR = baseR * 0.9;

      let dist = Math.hypot(dx, dy);
      let nx = 0, ny = 0, intensity = 0;

      if (dist > 0) {
        const clamped = Math.min(dist, maxR);
        nx = dx / dist;
        ny = dy / dist;
        intensity = clamped / maxR; // 0 ~ 1

        const knobX = joyCenterX + nx * clamped;
        const knobY = joyCenterY + ny * clamped;
        stickKnob.style.left = ((knobX - rect.left) / rect.width * 100) + '%';
        stickKnob.style.top  = ((knobY - rect.top)  / rect.height * 100) + '%';
      } else {
        stickKnob.style.left = '50%';
        stickKnob.style.top  = '50%';
      }

      // ğŸ”¹ ê°ë„ ì—…: ì¡°ê¸ˆë§Œ ì›€ì§ì—¬ë„ ë¹ ë¥´ê²Œ ë°˜ì‘
      const deadZone = 0.04;  // ì¤‘ì•™ ì‚´ì§ í”ë“¤ë¦¬ëŠ” êµ¬ê°„
      if (intensity < deadZone) {
        joyDirX = 0;
        joyDirY = 0;
        joyIntensity = 0;
      } else {
        joyDirX = nx;
        joyDirY = ny;

        // 0~1 ë¡œ ë…¸ë©€ë¼ì´ì¦ˆ
        let norm = (intensity - deadZone) / (1 - deadZone);
        if (norm < 0) norm = 0;
        if (norm > 1) norm = 1;

        // ê°ë„ ë¶€ìŠ¤íŠ¸: ì¤‘ê°„ê°’ì„ ìœ„ë¡œ ëŒì–´ì˜¬ë¦¼
        // (ì˜ˆ: ë°˜ì¯¤ë§Œ ë°€ì–´ë„ 70~80% ì†ë„ ëŠë‚Œ)
        norm = Math.min(1, norm * 1.35);

        joyIntensity = norm;
      }
    }

    function joystickTouchEnd(e) {
      const touches = e.changedTouches;
      for (let i = 0; i < touches.length; i++) {
        if (touches[i].identifier === joyId) {
          resetJoystick();
          break;
        }
      }
    }

    joystick.addEventListener('touchstart', joystickTouchStart, {passive:false});
    joystick.addEventListener('touchmove',  joystickTouchMove,  {passive:false});
    joystick.addEventListener('touchend',   joystickTouchEnd,   {passive:false});
    joystick.addEventListener('touchcancel',joystickTouchEnd,   {passive:false});

    // ===== ê²Œì„ ìƒíƒœ =====
    let gameMode = 'start'; // start, play, upgrade, dead, clear

    const meta = {
      totalEnergy: 0,
      attackLevel: 0,
      fireRateLevel: 0,
      moveSpeedLevel: 0,
      stageLevel: 0   // 0~4
    };

    // ì „ì²´ ëŸ¬ë‹ ë™ì•ˆ ëˆ„ì  ìŠ¤ì½”ì–´
    const stats = {
      totalKills: 0,
      totalSurvivalTime: 0,   // ì´ˆ ë‹¨ìœ„ dt ëˆ„ì 
      totalEnergyGained: 0
    };

    let player = null;
    let enemies = [];
    let bullets = [];
    let enemyBullets = [];
    let energies = [];
    let boss = null;

    let runTime = 0;
    let cycleCount = 0; // ì´ ìŠ¤í…Œì´ì§€ì—ì„œ ë‹¬ì´ ì´ˆë¡ì´ ëœ íšŸìˆ˜
    let cycleTime = 0;
    let isGreen = false;
    let greenTimer = 0;

    let spawnTimer = 0;
    let difficultyFactor = 1;
    let runEnergy = 0;
    let attackCooldown = 0;

    let lastClearType = 'escape';

    // ===== ìŠ¤í…Œì´ì§€ë³„ í•˜ë‹¨ ì•ˆë‚´ ë¬¸êµ¬ (5ìŠ¤í…Œì´ì§€ëŠ” ì—†ìŒ) =====
    const stageHints = [
      'ì™¼ìª½ ë™ê·¸ë¼ë¯¸ë¥¼ ë“œë˜ê·¸í•´ì„œ ì´ë™,\në‹¬ì´ ì´ˆë¡ìƒ‰ì¼ ë•Œ ì˜¤ë¥¸ìª½ ë²„íŠ¼ìœ¼ë¡œ í˜„ì‹¤ë¡œ ê·€í™˜.', // Stage 1
      'ë‹¬ì€ ë§¤ 29.5ì´ˆë§ˆë‹¤ ë‹¤ì‹œ ì´ˆë¡ìƒ‰ì´ ë©ë‹ˆë‹¤.',           // Stage 2
      'íšŒìƒ‰ì§€ëŒ€ì—ëŠ” ë‹¤ì–‘í•œ ë””ì†Œë”ê°€ ì¡´ì¬í•©ë‹ˆë‹¤.',             // Stage 3
      'ì£½ì§€ ì•Šì„ ë§Œí¼ ë‹¤ì¹œ ìƒì²˜ëŠ”\ní˜„ì‹¤ë¡œ ê·€í™˜í•˜ë©´ ëª¨ë‘ ì¹˜ë£Œë©ë‹ˆë‹¤.' // Stage 4
    ];
    let hintTimeout = null;

    function showStageHint() {
      if (!smallHint) return;

      // 5ìŠ¤í…Œì´ì§€(ë³´ìŠ¤)ëŠ” í•˜ë‹¨ ë¬¸êµ¬ ì—†ìŒ
      if (meta.stageLevel >= stageHints.length) {
        smallHint.textContent = '';
        smallHint.classList.remove('visible');
        if (hintTimeout) {
          clearTimeout(hintTimeout);
          hintTimeout = null;
        }
        return;
      }

      const text = stageHints[meta.stageLevel];
      smallHint.textContent = text || '';
      smallHint.classList.add('visible');

      if (hintTimeout) {
        clearTimeout(hintTimeout);
        hintTimeout = null;
      }
    }

    // ===== ë°¸ëŸ°ìŠ¤ ìƒìˆ˜ =====
    const MELEE_RANGE = 80;
    const BASE_SPAWN_INTERVAL = 1.35;
    const PLAYER_BASE_SPEED = 140;

    const ENEMY_BASE_SPEED = 38;
    const ENEMY_BASE_HP    = 30;

    const BULLET_SPEED  = 240;
    const BULLET_RADIUS = 3;

    const ENEMY_BULLET_SPEED  = 160;
    const ENEMY_BULLET_DAMAGE = 16;
    const ENEMY_ATTACK_COOLDOWN = 2.2;
    const ENEMY_ATTACK_RANGE  = 420;

    const DASH_RANGE      = 520;
    const DASH_DURATION   = 0.45;
    const DASH_COOLDOWN   = 2.4;
    const DASH_SPEED_MULT = 4.0;

    const BULLET_KNOCKBACK = 10;
    const MELEE_KNOCKBACK  = 18;

    const BOSS_CONTACT_DPS        = 12;
    const BOSS_BULLET_DAMAGE_MULT = 0.7;

    const BASE_ATTACK_COOLDOWN = 0.45;

    // ===== ìœ í‹¸ =====
    function formatTime(t) {
      const s = Math.floor(t);
      const m = Math.floor(s / 60);
      const ss = s % 60;
      return String(m).padStart(2,'0') + ':' + String(ss).padStart(2,'0');
    }

    function rotateVector(x, y, ang) {
      const c = Math.cos(ang);
      const s = Math.sin(ang);
      return [x*c - y*s, x*s + y*c];
    }

    // ===== ì—…ê·¸ë ˆì´ë“œ / ê³µê²©ë ¥ =====
    function getPlayerSpeed() {
      return PLAYER_BASE_SPEED * (1 + 0.1 * meta.moveSpeedLevel);
    }
    function getBulletDamage() {
      return 21 * (1 + 0.35 * meta.attackLevel);
    }
    function getMeleeDamage() {
      return 35 * (1 + 0.35 * meta.attackLevel);
    }

    function updateUpgradeUI() {
      upgradeStats.textContent =
        `íšŒìƒ‰ì§€ëŒ€ ìŠ¤í…Œì´ì§€: ${meta.stageLevel + 1} / 5\n` +
        `ë³´ìœ  í˜„ì‹¤ ì—ë„ˆì§€: ${meta.totalEnergy}\n` +
        `ê³µê²©ë ¥ Lv.${meta.attackLevel} | ë°œì‚¬ Lv.${meta.fireRateLevel} | ì´ë™ Lv.${meta.moveSpeedLevel}`;
    }

    function attemptUpgrade(type) {
      const cost = 10;
      if (meta.totalEnergy < cost) return;
      meta.totalEnergy -= cost;
      if (type === 'attack')    meta.attackLevel++;
      if (type === 'fireRate')  meta.fireRateLevel++;
      if (type === 'moveSpeed') meta.moveSpeedLevel++;
      updateUpgradeUI();
    }

    upgradeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const type = btn.dataset.upgrade;
        attemptUpgrade(type);
      });
    });

    // ===== ë°ë¯¸ì§€ / íŒ¨ë°° =====
    function damagePlayer(amount) {
      if (gameMode !== 'play' || !player) return;
      player.hp -= amount;
      if (player.hp <= 0) {
        player.hp = 0;
        onPlayerDead();
      }
    }

    // íŒ¨ë°° ì‹œ ìŠ¤ì½”ì–´ UI ì—…ë°ì´íŠ¸
    function updateDeadScoreUI() {
      if (!deadScoreBreakdown || !deadScoreFinal) return;

      const kills = stats.totalKills || 0;
      const totalTimeSec = Math.floor(stats.totalSurvivalTime || 0);
      const totalEnergy = stats.totalEnergyGained || 0;
      const totalScore = kills + totalTimeSec + totalEnergy;

      deadScoreBreakdown.textContent =
        `ì²˜ì¹˜í•œ ë””ì†Œë” ìˆ˜ : ${kills}\n` +
        `ì´ ë²„í‹´ ì‹œê°„      : ${totalTimeSec}ì´ˆ\n` +
        `ì´ íšë“ ì—ë„ˆì§€    : ${totalEnergy}`;

      deadScoreFinal.textContent = `ì´ ìŠ¤ì½”ì–´ : ${totalScore}`;
    }

    function resetAllProgress() {
      meta.totalEnergy    = 0;
      meta.attackLevel    = 0;
      meta.fireRateLevel  = 0;
      meta.moveSpeedLevel = 0;
      meta.stageLevel     = 0;

      runEnergy   = 0;
      runTime     = 0;
      cycleCount  = 0;
      cycleTime   = 0;
      isGreen     = false;
      greenTimer  = 0;
      spawnTimer  = 0;
      attackCooldown = 0;
      difficultyFactor = 1;
    }

    function resetRunForCurrentStage() {
      gameMode = 'play';

      resetJoystick();
      deadOverlay.classList.add('hidden');
      clearOverlay.classList.add('hidden');
      startOverlay.classList.add('hidden');
      upgradeOverlay.classList.add('hidden');
      tutorialHint.classList.add('hidden');
      screenFrame.classList.remove('green');

      runTime       = 0;
      cycleTime     = 0;
      cycleCount    = 0;
      isGreen       = false;
      greenTimer    = 0;
      spawnTimer    = 0;
      attackCooldown = 0;
      runEnergy     = 0;

      difficultyFactor = 1 + 0.18 * meta.stageLevel;

      player = {
        x: viewW / 2,
        y: viewH / 2,
        radius: 8,
        hp: 100,
        maxHp: 100
      };
      enemies      = [];
      bullets      = [];
      enemyBullets = [];
      energies     = [];
      boss         = null;

      if (meta.stageLevel === 4) {
        boss = {
          x: viewW / 2,
          y: viewH / 3,
          radius: player.radius * 1.2,
          hp: 26000,
          maxHp: 26000,
          baseSpeed: 45,
          patternCooldown: 1.0
        };
      }

      showStageHint();
      updateHud();
    }

    function hardRestart() {
      resetAllProgress();
      stats.totalKills = 0;
      stats.totalSurvivalTime = 0;
      stats.totalEnergyGained = 0;
      resetRunForCurrentStage();
    }

    function onPlayerDead() {
      gameMode = 'dead';

      updateDeadScoreUI();

      resetAllProgress();

      enemies      = [];
      bullets      = [];
      enemyBullets = [];
      energies     = [];
      boss         = null;
      isGreen      = false;

      screenFrame.classList.remove('green');
      tutorialHint.classList.add('hidden');
      resetJoystick();

      deadOverlay.classList.remove('hidden');
      upgradeOverlay.classList.add('hidden');
      clearOverlay.classList.add('hidden');
      startOverlay.classList.add('hidden');
    }

    // ===== í˜„ì‹¤ë¡œ ê·€í™˜ / ì—…ê·¸ë ˆì´ë“œ / í´ë¦¬ì–´ =====
    function moveToUpgrade() {
      gameMode = 'upgrade';
      meta.totalEnergy += runEnergy;
      runEnergy = 0;
      isGreen = false;
      screenFrame.classList.remove('green');
      tutorialHint.classList.add('hidden');
      enemies      = [];
      bullets      = [];
      enemyBullets = [];
      energies     = [];
      boss         = null;

      updateUpgradeUI();
      upgradeOverlay.classList.remove('hidden');
    }

    function continueToNextStage() {
      if (meta.stageLevel < 4) meta.stageLevel++;
      upgradeOverlay.classList.add('hidden');
      resetRunForCurrentStage();
    }

    upgradeContinue.addEventListener('click', () => {
      ensureBgm();
      continueToNextStage();
    });

    function onGameClear(type) {
      lastClearType = type || 'escape';
      gameMode = 'clear';

      enemies      = [];
      bullets      = [];
      enemyBullets = [];
      energies     = [];
      boss         = null;
      isGreen      = false;

      screenFrame.classList.remove('green');
      tutorialHint.classList.add('hidden');
      resetJoystick();

      if (clearText) {
        if (lastClearType === 'bossKill') {
          clearText.textContent = 'ìë„¨ ìµœê³ ì˜ ì˜¤ì„œë…ì„œê°€ ë  ìì§ˆì„ ê°€ì¡Œêµ¬ë§Œ.';
        } else {
          clearText.textContent = 'ìë„¨ ì•„ì£¼ ë›°ì–´ë‚œ ì˜¤ì„œë…ì„œì˜ ìì§ˆì„ ê°€ì¡Œêµ¬ë§Œ.';
        }
      }

      clearOverlay.classList.remove('hidden');
      upgradeOverlay.classList.add('hidden');
      deadOverlay.classList.add('hidden');
      startOverlay.classList.add('hidden');
    }

    function handleReturnButton() {
      if (gameMode !== 'play') return;
      if (!isGreen) return;
      if (!player || player.hp <= 0) return;

      // 5ìŠ¤í…Œì´ì§€(ë³´ìŠ¤)ì—ì„œëŠ” ê·€í™˜ ë²„íŠ¼ìœ¼ë¡œ íƒˆì¶œ í´ë¦¬ì–´
      if (meta.stageLevel === 4) {
        onGameClear('escape');
      } else {
        moveToUpgrade();
      }
    }

    returnButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      ensureBgm();
      handleReturnButton();
    }, {passive:false});
    returnButton.addEventListener('click', (e) => {
      e.preventDefault();
      ensureBgm();
      handleReturnButton();
    });

    // ===== ì‹œì‘ / ì¬ì‹œì‘ =====
    function startGameFromTitle() {
      ensureBgm();
      hardRestart();
    }

    startButton.addEventListener('click', () => {
      startGameFromTitle();
    });
    startOverlay.addEventListener('touchstart', (e) => {
      e.preventDefault();
      startGameFromTitle();
    }, {passive:false});

    // ì™„ì „ ìƒˆë¡œ ì‹œì‘ (ì„œë¹„ìŠ¤ì›Œì»¤ ê³ ë ¤í•´ì„œ ìƒˆë¡œê³ ì¹¨)
    function restartFromScratch() {
      location.hash = '#restart';
      location.reload();
    }

    deadRestart.addEventListener('click', (e) => {
      e.preventDefault();
      restartFromScratch();
    });
    clearRestart.addEventListener('click', (e) => {
      e.preventDefault();
      restartFromScratch();
    });

    // ===== ì  / ì—ë„ˆì§€ / ë³´ìŠ¤ =====
    function getEnergyAmountForType(type) {
      if (type === 'dasher')  return 1;
      if (type === 'fast')    return 2;
      if (type === 'slow')    return 2;
      if (type === 'runner')  return 4;
      if (type === 'spreader')return 8;
      return 1;
    }

    // ëª¨ë“  ìŠ¤í…Œì´ì§€(0~3)ì— ëŒ€í•´, 29.5ì´ˆ ì´ìƒ ë²„í‹°ë©° ë‹¬ì´ ì—¬ëŸ¬ ë²ˆ ì´ˆë¡ì´ ë˜ë©´
    // ë” ê°•í•œ ì  ì¡°í•©ì„ ì“°ë„ë¡ í™•ì¥
    function chooseEnemyType() {
      let baseStage = meta.stageLevel;
      if (baseStage > 3) baseStage = 3;

      let extra = 0;
      if (cycleCount >= 2) extra = 2;
      else if (cycleCount >= 1) extra = 1;

      let stage = baseStage + extra;
      if (stage > 3) stage = 3;

      const r = Math.random();
      if (stage === 0) {
        return 'dasher';
      } else if (stage === 1) {
        if (r < 0.6) return 'dasher';
        return 'fast';
      } else if (stage === 2) {
        if (r < 0.4) return 'dasher';
        else if (r < 0.7) return 'fast';
        else return 'slow';
      } else {
        if (r < 0.30) return 'dasher';
        else if (r < 0.55) return 'fast';
        else if (r < 0.75) return 'slow';
        else if (r < 0.88) return 'runner';
        else return 'spreader';
      }
    }

    function spawnEnemy() {
      // ë³´ìŠ¤ ìŠ¤í…Œì´ì§€ì—ì„œëŠ” ì¼ë°˜ ì  ìŠ¤í° X
      if (meta.stageLevel === 4) return;

      const side = Math.floor(Math.random() * 4);
      let x, y;
      if (side === 0) { x = -20;         y = Math.random() * viewH; }
      else if (side === 1) { x = viewW + 20; y = Math.random() * viewH; }
      else if (side === 2) { x = Math.random() * viewW; y = -20; }
      else { x = Math.random() * viewW; y = viewH + 20; }

      const type = chooseEnemyType();
      const energyTier = getEnergyAmountForType(type);
      const diff = difficultyFactor;

      let hp = ENEMY_BASE_HP * diff;
      let baseSpeed = ENEMY_BASE_SPEED * diff;

      if (type === 'dasher') {
        hp *= 1.0;
        baseSpeed *= 1.0;
      } else if (type === 'fast') {
        hp *= 1.2;
        baseSpeed *= 1.2;
      } else if (type === 'slow') {
        hp *= 1.6;
        baseSpeed *= 0.7;
      } else if (type === 'runner') {
        hp *= 1.3;
        baseSpeed *= 1.7;
      } else if (type === 'spreader') {
        hp *= 1.9;
        baseSpeed *= 0.9;
      }

      enemies.push({
        x, y,
        radius: 10,
        hp,
        baseSpeed,
        type,
        energyTier,
        attackCooldown: 0.6 + Math.random(),
        dashTime: 0
      });
    }

    function spawnEnemyBullet(x, y, ux, uy, speed, damage) {
      enemyBullets.push({
        x, y,
        vx: ux * speed,
        vy: uy * speed,
        radius: 3,
        damage
      });
    }

    function performEnemyAttack(e, dx, dy) {
      const d = Math.hypot(dx, dy) || 1;
      const ux = dx / d;
      const uy = dy / d;

      const baseCd = ENEMY_ATTACK_COOLDOWN / difficultyFactor;
      let cdMul = 1;

      if (e.type === 'fast') {
        spawnEnemyBullet(e.x, e.y, ux, uy, ENEMY_BULLET_SPEED * 1.5, ENEMY_BULLET_DAMAGE * 0.9);
        cdMul = 0.9;
      } else if (e.type === 'slow') {
        spawnEnemyBullet(e.x, e.y, ux, uy, ENEMY_BULLET_SPEED * 0.6, ENEMY_BULLET_DAMAGE * 1.3);
        cdMul = 1.3;
      } else if (e.type === 'runner') {
        if (Math.random() < 0.45) {
          spawnEnemyBullet(e.x, e.y, ux, uy, ENEMY_BULLET_SPEED * 1.1, ENEMY_BULLET_DAMAGE * 0.7);
        }
        cdMul = 1.5;
      } else if (e.type === 'spreader') {
        const step = 0.18;
        for (let i = -3; i <= 3; i++) {
          const ang = i * step;
          const [vx, vy] = rotateVector(ux, uy, ang);
          spawnEnemyBullet(e.x, e.y, vx, vy, ENEMY_BULLET_SPEED * 1.0, ENEMY_BULLET_DAMAGE * 0.9);
        }
        cdMul = 1.6;
      } else {
        if (Math.random() < 0.3) {
          spawnEnemyBullet(e.x, e.y, ux, uy, ENEMY_BULLET_SPEED, ENEMY_BULLET_DAMAGE);
        }
        cdMul = 1.4;
      }

      e.attackCooldown = baseCd * cdMul * (0.7 + Math.random() * 0.7);
    }

    // ===== ë³´ìŠ¤ =====
    function updateBoss(dt) {
      if (!boss || gameMode !== 'play' || !player) return;

      const dx = player.x - boss.x;
      const dy = player.y - boss.y;
      const dist = Math.hypot(dx, dy) || 1;
      const speed = boss.baseSpeed;
      boss.x += (dx / dist) * speed * dt;
      boss.y += (dy / dist) * speed * dt;

      const pd = Math.hypot(player.x - boss.x, player.y - boss.y);
      if (pd < player.radius + boss.radius) {
        damagePlayer(BOSS_CONTACT_DPS * dt);
      }

      boss.patternCooldown -= dt;
      if (boss.patternCooldown <= 0) {
        performBossPattern();
        boss.patternCooldown = 1.0;
      }

      if (boss.hp <= 0 && gameMode === 'play') {
        boss.hp = 0;
        boss = null;
        runEnergy += 8;
        stats.totalKills += 1;
        stats.totalEnergyGained += 8;
        onGameClear('bossKill');
      }
    }

    function performBossPattern() {
      if (!boss || !player) return;

      const dx = player.x - boss.x;
      const dy = player.y - boss.y;
      const dist = Math.hypot(dx, dy) || 1;
      const ux = dx / dist;
      const uy = dy / dist;

      const pattern = Math.floor(Math.random() * 4);

      if (pattern === 0) {
        const count = 18;
        const step = 0.16;
        for (let i = 0; i < count; i++) {
          const offset = (i - (count-1)/2) * step;
          const [vx, vy] = rotateVector(ux, uy, offset);
          spawnEnemyBullet(
            boss.x, boss.y,
            vx, vy,
            ENEMY_BULLET_SPEED * 1.3,
            ENEMY_BULLET_DAMAGE * 0.8 * BOSS_BULLET_DAMAGE_MULT
          );
        }
      } else if (pattern === 1) {
        const angles = [-0.18, 0, 0.18];
        const speeds = [
          ENEMY_BULLET_SPEED * 1.2,
          ENEMY_BULLET_SPEED * 1.0,
          ENEMY_BULLET_SPEED * 0.9
        ];
        for (let k = 0; k < angles.length; k++) {
          const base = angles[k];
          for (let i = -2; i <= 2; i++) {
            const off = base + i * 0.06;
            const [vx, vy] = rotateVector(ux, uy, off);
            spawnEnemyBullet(
              boss.x, boss.y,
              vx, vy,
              speeds[k],
              ENEMY_BULLET_DAMAGE * 0.7 * BOSS_BULLET_DAMAGE_MULT
            );
          }
        }
      } else if (pattern === 2) {
        const baseCount = 10;
        for (let i = 0; i < baseCount; i++) {
          const ang = (Math.PI * 2 * i) / baseCount;
          const vx = Math.cos(ang);
          const vy = Math.sin(ang);
          spawnEnemyBullet(
            boss.x, boss.y,
            vx, vy,
            ENEMY_BULLET_SPEED * 0.9,
            ENEMY_BULLET_DAMAGE * 0.9 * BOSS_BULLET_DAMAGE_MULT
          );
          spawnEnemyBullet(
            boss.x, boss.y,
            vx, vy,
            ENEMY_BULLET_SPEED * 1.2,
            ENEMY_BULLET_DAMAGE * 0.7 * BOSS_BULLET_DAMAGE_MULT
          );
        }
      } else {
        const outerCount = 24;
        const innerCount = 16;
        for (let i = 0; i < outerCount; i++) {
          const ang = (Math.PI * 2 * i) / outerCount;
          const vx = Math.cos(ang);
          const vy = Math.sin(ang);
          spawnEnemyBullet(
            boss.x, boss.y,
            vx, vy,
            ENEMY_BULLET_SPEED * 1.0,
            ENEMY_BULLET_DAMAGE * 0.8 * BOSS_BULLET_DAMAGE_MULT
          );
        }
        for (let i = 0; i < innerCount; i++) {
          const ang = (Math.PI * 2 * i) / innerCount + Math.PI / innerCount;
          const vx = Math.cos(ang);
          const vy = Math.sin(ang);
          spawnEnemyBullet(
            boss.x, boss.y,
            vx, vy,
            ENEMY_BULLET_SPEED * 0.7,
            ENEMY_BULLET_DAMAGE * 0.8 * BOSS_BULLET_DAMAGE_MULT
          );
        }
      }
    }

    // ===== ë©”ì¸ ì—…ë°ì´íŠ¸ =====
    function update(dt) {
      if (gameMode !== 'play' || !player) return;

      runTime += dt;
      stats.totalSurvivalTime += dt;
      cycleTime += dt;

      // ë‹¬ì´ ì´ˆë¡ìœ¼ë¡œ ë³€í•˜ëŠ” íƒ€ì´ë°
      if (!isGreen && cycleTime >= 29.5) {
        isGreen = true;
        greenTimer = 2.0;
        cycleTime = 0;
        cycleCount++;

        if (meta.stageLevel === 0) {
          tutorialHint.classList.remove('hidden');
        }
      }
      if (isGreen) {
        greenTimer -= dt;
        if (greenTimer <= 0) {
          isGreen = false;
          greenTimer = 0;
          tutorialHint.classList.add('hidden');
        }
      }

      // ì¼ë°˜ ì  ìŠ¤í° (ë³´ìŠ¤ ìŠ¤í…Œì´ì§€ ì œì™¸)
      if (meta.stageLevel !== 4) {
        spawnTimer -= dt;
        if (spawnTimer <= 0) {
          spawnEnemy();
          spawnEnemy(); // ê¸°ë³¸ 2ë°° ìŠ¤í°
          const diffMul = 1 + 0.2 * meta.stageLevel + 0.25 * cycleCount;
          spawnTimer = (BASE_SPAWN_INTERVAL / diffMul) * (0.7 + Math.random() * 0.6);
        }
      }

      // í”Œë ˆì´ì–´ ì´ë™ (ì¡°ì´ìŠ¤í‹± ë°©í–¥ + ì„¸ê¸° ë°˜ì˜)
      if (joyIntensity > 0 && (joyDirX !== 0 || joyDirY !== 0)) {
        let mvx = joyDirX;
        let mvy = joyDirY;
        const len = Math.hypot(mvx, mvy) || 1;
        mvx /= len;
        mvy /= len;

        const baseSpeed = getPlayerSpeed();
        const speed = baseSpeed * (0.4 + 0.6 * joyIntensity); // ì¡°ê¸ˆë§Œ ë°€ì–´ë„ ë¹ ë¥´ê²Œ ë°˜ì‘

        player.x += mvx * speed * dt;
        player.y += mvy * speed * dt;
      }

      // ìœ„/ì•„ë˜ í¬í•¨ í™”ë©´ ë°–ìœ¼ë¡œ ëª» ë‚˜ê°€ê²Œ í´ë¨í”„
      player.x = Math.max(player.radius, Math.min(viewW - player.radius, player.x));
      player.y = Math.max(player.radius, Math.min(viewH - player.radius, player.y));

      // ì  ì´ë™ / ê³µê²©
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.hypot(dx, dy) || 1;

        let speed = e.baseSpeed;
        if (e.type === 'dasher') {
          if (e.dashTime > 0) {
            speed *= DASH_SPEED_MULT;
            e.dashTime -= dt;
          }
          e.attackCooldown -= dt;
          if (e.attackCooldown <= 0 && dist < DASH_RANGE) {
            e.dashTime = DASH_DURATION;
            e.attackCooldown = (DASH_COOLDOWN / difficultyFactor) * (0.8 + Math.random() * 0.6);
          }
        } else {
          e.attackCooldown -= dt;
          if (e.attackCooldown <= 0 && dist < ENEMY_ATTACK_RANGE) {
            performEnemyAttack(e, dx, dy);
          }
        }

        e.x += (dx / dist) * speed * dt;
        e.y += (dy / dist) * speed * dt;

        if (dist < player.radius + e.radius) {
          const contactDps = (e.type === 'dasher') ? 36 : 16;
          damagePlayer(contactDps * dt);
        }
      }

      // ë³´ìŠ¤
      if (meta.stageLevel === 4) {
        updateBoss(dt);
      }

      // ìë™ ê³µê²©
      attackCooldown -= dt;
      if (attackCooldown <= 0) {
        let nearest = null;
        let nearestDist = Infinity;

        enemies.forEach(e => {
          const dx = e.x - player.x;
          const dy = e.y - player.y;
          const d = Math.hypot(dx, dy);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = e;
          }
        });

        if (boss && boss.hp > 0) {
          const dx = boss.x - player.x;
          const dy = boss.y - player.y;
          const d = Math.hypot(dx, dy);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = boss;
          }
        }

        if (nearest) {
          const fireRateMul = 1 + 0.2 * meta.fireRateLevel;
          const dx = nearest.x - player.x;
          const dy = nearest.y - player.y;
          const dist = Math.hypot(dx, dy) || 1;

          if (dist <= MELEE_RANGE) {
            const dmg = getMeleeDamage();
            if (nearest === boss) boss.hp -= dmg;
            else nearest.hp -= dmg;

            const nd = Math.hypot(dx, dy) || 1;
            if (nearest !== boss) {
              nearest.x += (dx / nd) * MELEE_KNOCKBACK;
              nearest.y += (dy / nd) * MELEE_KNOCKBACK;
            }
            attackCooldown = BASE_ATTACK_COOLDOWN / fireRateMul;
          } else {
            bullets.push({
              x: player.x,
              y: player.y,
              vx: (dx / dist) * BULLET_SPEED,
              vy: (dy / dist) * BULLET_SPEED,
              radius: BULLET_RADIUS,
              damage: getBulletDamage()
            });
            attackCooldown = BASE_ATTACK_COOLDOWN / fireRateMul;
          }
        }
      }

      // í”Œë ˆì´ì–´ íƒ„
      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx * dt;
        b.y += b.vy * dt;

        if (b.x < -40 || b.x > viewW + 40 || b.y < -40 || b.y > viewH + 40) {
          bullets.splice(i, 1);
          continue;
        }

        let hit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          const dx = e.x - b.x;
          const dy = e.y - b.y;
          const dist = Math.hypot(dx, dy);
          if (dist < e.radius + b.radius) {
            e.hp -= b.damage;
            const vl = Math.hypot(b.vx, b.vy) || 1;
            e.x += (b.vx / vl) * BULLET_KNOCKBACK;
            e.y += (b.vy / vl) * BULLET_KNOCKBACK;
            hit = true;
            break;
          }
        }

        if (!hit && boss && boss.hp > 0) {
          const dx = boss.x - b.x;
          const dy = boss.y - b.y;
          const dist = Math.hypot(dx, dy);
          if (dist < boss.radius + b.radius) {
            boss.hp -= b.damage;
            hit = true;
          }
        }

        if (hit) bullets.splice(i, 1);
      }

      // ì  ì‚¬ë§ â†’ ì—ë„ˆì§€ íŒŒí¸
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (e.hp <= 0) {
          enemies.splice(i, 1);
          stats.totalKills += 1;
          const amount = getEnergyAmountForType(e.type);
          let r = 3;
          if (amount === 2) r = 5;
          else if (amount === 4) r = 7;
          else if (amount >= 8) r = 9;
          energies.push({
            x: e.x,
            y: e.y,
            radius: r,
            amount,
            life: 5.0
          });
        }
      }

      // ì  íƒ„
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const eb = enemyBullets[i];
        eb.x += eb.vx * dt;
        eb.y += eb.vy * dt;
        if (eb.x < -40 || eb.x > viewW + 40 || eb.y < -40 || eb.y > viewH + 40) {
          enemyBullets.splice(i, 1);
          continue;
        }
        const dx = eb.x - player.x;
        const dy = eb.y - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist < eb.radius + player.radius) {
          damagePlayer(eb.damage);
          enemyBullets.splice(i, 1);
        }
      }

      // ì—ë„ˆì§€ íŒŒí¸ ì¤ê¸°
      for (let i = energies.length - 1; i >= 0; i--) {
        const g = energies[i];
        g.life -= dt;
        if (g.life <= 0) {
          energies.splice(i, 1);
          continue;
        }
        const dx = g.x - player.x;
        const dy = g.y - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist < player.radius + g.radius) {
          runEnergy += g.amount;
          stats.totalEnergyGained += g.amount;
          energies.splice(i, 1);
        }
      }

      updateHud();
    }

    function updateHud() {
      const stageNum = meta.stageLevel + 1;
      hudStage.textContent = `Stage ${stageNum} (íšŒìƒ‰ì§€ëŒ€)`;
      hudHp.textContent = `HP ${player ? Math.round(player.hp) : 0}`;
      hudTimer.textContent = formatTime(runTime);
      hudEnergy.textContent = `ì—ë„ˆì§€: ${runEnergy} | ì´: ${meta.totalEnergy}`;

      if (gameMode === 'play' && isGreen && player && player.hp > 0) {
        returnButton.classList.remove('disabled');
        returnButton.classList.add('active');
      } else {
        returnButton.classList.add('disabled');
        returnButton.classList.remove('active');
      }

      screenFrame.classList.toggle('green', (gameMode === 'play' && isGreen));
    }

    // ===== ë Œë” =====
    function draw() {
      if (!ctx) return;

      const grad = ctx.createRadialGradient(
        viewW/2, viewH/2, 40,
        viewW/2, viewH/2, Math.max(viewW, viewH)
      );
      grad.addColorStop(0, '#050515');
      grad.addColorStop(1, '#000000');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, viewW, viewH);

      // ë‹¬ (ìš°ì¸¡ ìƒë‹¨)
      const moonX = viewW - 60;
      const moonY = 50;
      ctx.save();
      ctx.translate(moonX, moonY);
      ctx.beginPath();
      ctx.arc(0, 0, 28, 0, Math.PI * 2);
      ctx.fillStyle = isGreen ? '#00ff99' : '#ff4444';
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#ffffff';
      ctx.stroke();

      ctx.globalAlpha = 0.22;
      ctx.beginPath();
      ctx.arc(0, 0, 42, 0, Math.PI * 2);
      ctx.strokeStyle = isGreen ? '#00ffbb' : '#ff8888';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();

      if (!player) return;

      // í”Œë ˆì´ì–´
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#4af0ff';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius+3, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(74,240,255,0.4)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // ê·¼ì ‘ ë²”ìœ„
      ctx.beginPath();
      ctx.arc(player.x, player.y, MELEE_RANGE, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 1;
      ctx.stroke();

      // ì 
      enemies.forEach(e => {
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#555555';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius+3, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(30,30,30,0.9)';
        ctx.lineWidth = 4;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius-4, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(190,190,220,0.7)';
        ctx.lineWidth = 2;
        ctx.stroke();
      });

      // ë³´ìŠ¤
      if (boss && boss.hp > 0) {
        ctx.beginPath();
        ctx.arc(boss.x, boss.y, boss.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#333399';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(boss.x, boss.y, boss.radius+6, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(200,200,255,0.8)';
        ctx.lineWidth = 4;
        ctx.stroke();

        const barW = Math.min(viewW - 40, 260);
        const barH = 14;
        const x = (viewW - barW) / 2;
        const y = 90;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(x-2, y-2, barW+4, barH+4);
        const ratio = Math.max(0, boss.hp / boss.maxHp);
        ctx.fillStyle = '#00ff99';
        ctx.fillRect(x, y, barW * ratio, barH);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, barW, barH);
        ctx.font = '11px system-ui';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffffff';
        ctx.fillText(`BOSS HP ${Math.max(0, Math.round(boss.hp))}/${boss.maxHp}`, x + barW/2, y - 4);
      }

      // í”Œë ˆì´ì–´ íƒ„
      bullets.forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#00b7ff';
        ctx.fill();
      });

      // ì  íƒ„
      enemyBullets.forEach(eb => {
        ctx.beginPath();
        ctx.arc(eb.x, eb.y, eb.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#ff6666';
        ctx.fill();
      });

      // ì—ë„ˆì§€
      energies.forEach(g => {
        const alpha = Math.max(0, Math.min(1, g.life / 5));
        ctx.beginPath();
        ctx.arc(g.x, g.y, g.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,213,74,${0.3 + 0.5*alpha})`;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(g.x, g.y, g.radius+2, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255,213,74,${0.4*alpha})`;
        ctx.lineWidth = 1;
        ctx.stroke();
      });
    }

    // ===== ë£¨í”„ =====
    let lastTime = performance.now();
    function loop(now) {
      const dtRaw = (now - lastTime) / 1000;
      lastTime = now;
      const dt = Math.min(dtRaw, 0.05);

      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // í•´ì‹œê°€ #restart ì¸ ìƒíƒœë¡œ ë“¤ì–´ì˜¨ ê²½ìš° â†’ ì™„ì „ ìƒˆ ì‹œì‘
    if (location.hash === '#restart') {
      if (history.replaceState) {
        history.replaceState(null, '', location.pathname + location.search);
      } else {
        location.hash = '';
      }
      resetAllProgress();
      stats.totalKills = 0;
      stats.totalSurvivalTime = 0;
      stats.totalEnergyGained = 0;
      resetRunForCurrentStage();
    }

    // ===== ì„œë¹„ìŠ¤ì›Œì»¤ (ì˜µì…˜) =====
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch(() => {});
      });
    }
  </script>
</body>
</html>






